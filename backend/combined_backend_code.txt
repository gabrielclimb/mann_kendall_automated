------
./manage.py
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""

import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault(
        "DJANGO_SETTINGS_MODULE", "src.infrastructure.django.settings"
    )
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()
------
./src/__init__.py
------
./src/application/__init__.py
------
./src/application/use_cases/perform_mann_kendall_analysis.py
from datetime import datetime
from typing import List
from uuid import UUID, uuid4

import numpy as np
import pandas as pd
from scipy.stats import norm
from src.domain.entities.analysis_result import AnalysisResult
from src.domain.ports.analysis_repository import AnalysisRepository


class PerformMannKendallAnalysis:
    """Use case for performing Mann-Kendall trend analysis"""

    def __init__(self, analysis_repository: AnalysisRepository):
        self.analysis_repository = analysis_repository

    def _transpose_dataframe(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Transposes the given DataFrame, replaces "ND" with 0.5, and renames columns.
        Uses position-based column naming.

        Args:
            data: DataFrame with wells as columns and dates as first row

        Returns:
            pd.DataFrame: Transposed DataFrame with modified columns.
        """
        df = data.replace("ND", 0.5)
        df_transposto = df.T
        # Use positions to rename columns, not names
        df_transposto.columns.values[0] = "well"
        df_transposto.columns.values[1] = "Date"
        return df_transposto

    async def execute(
        self, dataset_id: UUID, data: pd.DataFrame
    ) -> List[AnalysisResult]:
        """Execute Mann-Kendall analysis on the provided dataset"""
        try:
            # Transform the data using original position-based method
            df_transformed = self._transpose_dataframe(data)

            # Get wells with sufficient data points (>4)
            wells = pd.DataFrame(df_transformed.well.value_counts() > 4).reset_index()
            wells.columns = ["index", "well"]
            wells = wells[wells.well].iloc[:, 0]

            # Parameters to analyze (all columns except well and date)
            parameters = df_transformed.columns[2:]

            results = []

            # Perform analysis for each well and parameter
            for well in wells:
                df_well = df_transformed[df_transformed.well == well]

                for param in parameters:
                    try:
                        if df_well.loc[:, param].dropna().count() > 3:
                            values = df_well.loc[:, param].dropna().values

                            trend, s, cv, cf = self._mann_kendall_test(values)

                            result = AnalysisResult(
                                id=uuid4(),
                                dataset_id=dataset_id,
                                well_name=well,
                                parameter=param,
                                trend=trend,
                                statistic=s,
                                coefficient_variation=cv,
                                confidence_factor=cf,
                                analysis_date=datetime.utcnow(),
                                data_points=len(values),
                                minimum_value=float(np.min(values)),
                                maximum_value=float(np.max(values)),
                                mean_value=float(np.mean(values)),
                            )

                            await self.analysis_repository.save(result)
                            results.append(result)
                    except TypeError:
                        continue

            return results

        except Exception as e:
            raise ValueError(f"Error performing Mann-Kendall analysis: {str(e)}")

    def _mann_kendall_test(self, x: np.ndarray, alpha: float = 0.05) -> tuple:
        """
        Perform Mann-Kendall trend test.
        This is the same as your original implementation.
        """
        n = len(x)

        # Calculate S
        s = 0
        for k in range(n - 1):
            for j in range(k + 1, n):
                s += np.sign(x[j] - x[k])

        # Calculate variance
        unique_x = np.unique(x)
        g = len(unique_x)

        if n == g:  # No ties
            var_s = (n * (n - 1) * (2 * n + 5)) / 18
        else:  # Handle ties
            tp = np.zeros(unique_x.shape)
            for i, val in enumerate(unique_x):
                tp[i] = sum(x == val)
            var_s = (
                n * (n - 1) * (2 * n + 5) - np.sum(tp * (tp - 1) * (2 * tp + 5))
            ) / 18

        # Calculate Z
        if s > 0:
            z = (s - 1) / np.sqrt(var_s)
        elif s < 0:
            z = (s + 1) / np.sqrt(var_s)
        else:
            z = 0

        # Calculate coefficient of variation and confidence factor
        cv = np.std(x, ddof=1) / np.mean(x)
        p = 1 - norm.cdf(abs(z))
        cf = 1 - p

        # Determine trend
        if cf < 0.9:
            trend = "Stable" if s <= 0 and cv < 1 else "No Trend"
        else:
            if cf <= 0.95:
                trend = "Prob. Increasing" if s > 0 else "Prob. Decreasing"
            else:
                trend = "Increasing" if s > 0 else "Decreasing"

        return trend, round(s, 4), round(cv, 2), round(cf, 3)
------
./src/application/use_cases/__init__.py
------
./src/application/services/__init__.py
------
./src/infrastructure/__init__.py
------
./src/infrastructure/repositories/django_analysis_repository.py
# src/infrastructure/repositories/django_analysis_repository.py
from typing import List, Optional
from uuid import UUID

from asgiref.sync import sync_to_async
from src.domain.entities.analysis_result import AnalysisResult
from src.domain.ports.analysis_repository import AnalysisRepository
from src.infrastructure.django.models import AnalysisModel


class DjangoAnalysisRepository(AnalysisRepository):
    async def save(self, result: AnalysisResult) -> AnalysisResult:
        """Save analysis result to Django database"""
        analysis_dict = {
            "dataset_id": result.dataset_id,
            "status": "completed",
            "parameters": {
                "well_name": result.well_name,
                "parameter": result.parameter,
                "data_points": result.data_points,
                "minimum_value": result.minimum_value,
                "maximum_value": result.maximum_value,
                "mean_value": result.mean_value,
            },
            "results": {
                "trend": result.trend,
                "statistic": result.statistic,
                "coefficient_variation": result.coefficient_variation,
                "confidence_factor": result.confidence_factor,
            },
        }

        analysis_model = await AnalysisModel.objects.acreate(**analysis_dict)
        return self._to_entity(analysis_model)

    async def get_by_id(self, result_id: UUID) -> Optional[AnalysisResult]:
        """Retrieve analysis result by ID"""
        try:
            model = await AnalysisModel.objects.aget(id=result_id)
            return self._to_entity(model)
        except AnalysisModel.DoesNotExist:
            return None

    async def list_by_dataset(self, dataset_id: UUID) -> List[AnalysisResult]:
        """List all results for a dataset"""
        queryset = AnalysisModel.objects.filter(dataset_id=dataset_id)
        models = await sync_to_async(list)(queryset)
        results = []
        for model in models:
            try:
                result = self._to_entity(model)
                if result:
                    results.append(result)
            except (KeyError, TypeError):
                continue
        return results

    def _to_entity(self, model: AnalysisModel) -> Optional[AnalysisResult]:
        """Convert Django model to domain entity"""
        params = model.parameters or {}
        results = model.results or {}

        # Skip records without required data
        if not params or not results:
            return None

        try:
            return AnalysisResult(
                id=model.id,
                dataset_id=model.dataset_id,
                well_name=params.get("well_name", "Unknown"),
                parameter=params.get("parameter", "Unknown"),
                trend=results.get("trend", "No Trend"),
                statistic=results.get("statistic", 0.0),
                coefficient_variation=results.get("coefficient_variation", 0.0),
                confidence_factor=results.get("confidence_factor", 0.0),
                analysis_date=model.completed_at or model.created_at,
                data_points=params.get("data_points", 0),
                minimum_value=params.get("minimum_value", 0.0),
                maximum_value=params.get("maximum_value", 0.0),
                mean_value=params.get("mean_value", 0.0),
            )
        except Exception:
            return None
------
./src/infrastructure/repositories/django_project_repository.py
from typing import List, Optional
from uuid import UUID

from src.domain.entities.project import Project
from src.domain.ports.project_repository import ProjectRepository
from src.infrastructure.django.models import ProjectModel


class DjangoProjectRepository(ProjectRepository):
    async def save(self, project: Project) -> Project:
        project_model = await ProjectModel.objects.aupdate_or_create(
            id=project.id,
            defaults={
                "name": project.name,
                "description": project.description,
                "owner_id": project.owner_id,
            },
        )
        return self._to_entity(project_model[0])

    async def get_by_id(self, project_id: UUID) -> Optional[Project]:
        try:
            project_model = await ProjectModel.objects.aget(id=project_id)
            return self._to_entity(project_model)
        except ProjectModel.DoesNotExist:
            return None

    async def list_by_owner(self, owner_id: UUID) -> List[Project]:
        project_models = await ProjectModel.objects.filter(owner_id=owner_id)
        return [self._to_entity(pm) for pm in project_models]

    async def delete(self, project_id: UUID) -> None:
        await ProjectModel.objects.filter(id=project_id).adelete()

    async def update(self, project: Project) -> Project:
        project_model = await ProjectModel.objects.aget(id=project.id)
        project_model.name = project.name
        project_model.description = project.description
        await project_model.asave()
        return self._to_entity(project_model)

    def _to_entity(self, model: ProjectModel) -> Project:
        return Project(
            id=model.id,
            name=model.name,
            description=model.description,
            owner_id=model.owner.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )
------
./src/infrastructure/repositories/__init__.py
------
./src/infrastructure/django/migrations/0002_initial.py
# Generated by Django 5.1.4 on 2024-12-23 09:13

import uuid

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):
    initial = True

    dependencies = [
        ("django", "0001_initial"),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="DatasetModel",
            fields=[
                (
                    "id",
                    models.UUIDField(
                        default=uuid.uuid4,
                        editable=False,
                        primary_key=True,
                        serialize=False,
                    ),
                ),
                ("name", models.CharField(max_length=200)),
                ("file", models.FileField(upload_to="datasets/")),
                ("uploaded_at", models.DateTimeField(auto_now_add=True)),
                ("processed", models.BooleanField(default=False)),
            ],
            options={
                "db_table": "datasets",
                "ordering": ["-uploaded_at"],
            },
        ),
        migrations.CreateModel(
            name="AnalysisModel",
            fields=[
                (
                    "id",
                    models.UUIDField(
                        default=uuid.uuid4,
                        editable=False,
                        primary_key=True,
                        serialize=False,
                    ),
                ),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("pending", "Pending"),
                            ("processing", "Processing"),
                            ("completed", "Completed"),
                            ("failed", "Failed"),
                        ],
                        default="pending",
                        max_length=20,
                    ),
                ),
                ("parameters", models.JSONField(default=dict)),
                ("results", models.JSONField(blank=True, null=True)),
                ("error_message", models.TextField(blank=True, null=True)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("completed_at", models.DateTimeField(blank=True, null=True)),
                (
                    "dataset",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="analyses",
                        to="django.datasetmodel",
                    ),
                ),
            ],
            options={
                "verbose_name_plural": "analyses",
                "db_table": "analyses",
                "ordering": ["-created_at"],
            },
        ),
        migrations.CreateModel(
            name="ProjectModel",
            fields=[
                (
                    "id",
                    models.UUIDField(
                        default=uuid.uuid4,
                        editable=False,
                        primary_key=True,
                        serialize=False,
                    ),
                ),
                ("name", models.CharField(max_length=200)),
                ("description", models.TextField(blank=True, null=True)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "owner",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="projects",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
            options={
                "db_table": "projects",
                "ordering": ["-created_at"],
            },
        ),
        migrations.AddField(
            model_name="datasetmodel",
            name="project",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="datasets",
                to="django.projectmodel",
            ),
        ),
    ]
------
./src/infrastructure/django/migrations/__init__.py
------
./src/infrastructure/django/migrations/0003_update_analysis_model_parameters.py
# Generated by Django 5.1.4 on 2024-12-23 09:18

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("django", "0002_initial"),
    ]

    operations = [
        migrations.AlterField(
            model_name="analysismodel",
            name="parameters",
            field=models.JSONField(blank=True, default=dict, null=True),
        ),
    ]
------
./src/infrastructure/django/migrations/0001_initial.py
# Generated by Django 5.1.4 on 2024-12-23 09:13

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = []

    operations = []
------
./src/infrastructure/django/models.py
import uuid

from django.contrib.auth.models import User
from django.db import models


class ProjectModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=200)
    description = models.TextField(null=True, blank=True)
    owner = models.ForeignKey(User, on_delete=models.CASCADE, related_name="projects")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        app_label = "django"
        db_table = "projects"
        ordering = ["-created_at"]

    def __str__(self):
        return self.name


class DatasetModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    project = models.ForeignKey(
        ProjectModel, on_delete=models.CASCADE, related_name="datasets"
    )
    name = models.CharField(max_length=200)
    file = models.FileField(upload_to="datasets/")
    uploaded_at = models.DateTimeField(auto_now_add=True)
    processed = models.BooleanField(default=False)

    class Meta:
        app_label = "django"
        db_table = "datasets"
        ordering = ["-uploaded_at"]

    def __str__(self):
        return f"{self.name} ({self.project.name})"


class AnalysisModel(models.Model):
    STATUS_CHOICES = [
        ("pending", "Pending"),
        ("processing", "Processing"),
        ("completed", "Completed"),
        ("failed", "Failed"),
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    dataset = models.ForeignKey(
        DatasetModel, on_delete=models.CASCADE, related_name="analyses"
    )
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="pending")
    parameters = models.JSONField(default=dict, null=True, blank=True)  # Made nullable
    results = models.JSONField(null=True, blank=True)
    error_message = models.TextField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        app_label = "django"
        db_table = "analyses"
        ordering = ["-created_at"]
        verbose_name_plural = "analyses"

    def __str__(self):
        return f"Analysis for {self.dataset.name}"
------
./src/infrastructure/django/serializers.py
from rest_framework import serializers

from .models import AnalysisModel, DatasetModel, ProjectModel


class ProjectSerializer(serializers.ModelSerializer):
    owner = serializers.ReadOnlyField(source="owner.username")

    class Meta:
        model = ProjectModel
        fields = ["id", "name", "description", "owner", "created_at", "updated_at"]
        read_only_fields = ["created_at", "updated_at"]


class DatasetSerializer(serializers.ModelSerializer):
    class Meta:
        model = DatasetModel
        fields = ["id", "project", "name", "file", "uploaded_at", "processed"]
        read_only_fields = ["uploaded_at", "processed"]


class AnalysisSerializer(serializers.ModelSerializer):
    class Meta:
        model = AnalysisModel
        fields = [
            "id",
            "dataset",
            "status",
            "parameters",
            "results",
            "error_message",
            "created_at",
            "completed_at",
        ]
        read_only_fields = [
            "status",
            "results",
            "error_message",
            "created_at",
            "completed_at",
        ]

    def create(self, validated_data):
        # Ensure parameters has a default value if not provided
        if "parameters" not in validated_data:
            validated_data["parameters"] = {}
        return super().create(validated_data)
------
./src/infrastructure/django/__init__.py
from celery import app as celery_app

__all__ = ("celery_app",)
------
./src/infrastructure/django/apps.py
from django.apps import AppConfig


class MannKendallConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "mann_kendall"
    verbose_name = "Mann Kendall Analysis"


class DjangoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "src.infrastructure.django"
    label = "django"
    verbose_name = "Mann Kendall Analysis"
------
./src/infrastructure/django/admin.py
from django.contrib import admin

from .models import AnalysisModel, DatasetModel, ProjectModel


@admin.register(ProjectModel)
class ProjectAdmin(admin.ModelAdmin):
    list_display = ("name", "owner", "created_at", "updated_at")
    list_filter = ("created_at", "updated_at")
    search_fields = ("name", "description", "owner__username")
    date_hierarchy = "created_at"


@admin.register(DatasetModel)
class DatasetAdmin(admin.ModelAdmin):
    list_display = ("name", "project", "uploaded_at", "processed")
    list_filter = ("processed", "uploaded_at")
    search_fields = ("name", "project__name")
    date_hierarchy = "uploaded_at"


@admin.register(AnalysisModel)
class AnalysisAdmin(admin.ModelAdmin):
    list_display = ("dataset", "status", "created_at", "completed_at")
    list_filter = ("status", "created_at", "completed_at")
    search_fields = ("dataset__name", "error_message")
    date_hierarchy = "created_at"
    readonly_fields = ("created_at", "completed_at")
------
./src/infrastructure/django/settings.py
import os
from pathlib import Path

import dj_database_url
from dotenv import load_dotenv

# Carregar variáveis de ambiente
load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv("SECRET_KEY")

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.getenv("DEBUG", "False") == "True"

ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS", "").split(",")

# Application definition
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "rest_framework",
    "rest_framework.authtoken",
    "corsheaders",
    "django_celery_results",
    # "mann_kendall.apps.MannKendallConfig",
    "src.infrastructure.django.apps.DjangoConfig",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "src.infrastructure.django.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "src.infrastructure.django.wsgi.application"

# Database
DATABASES = {
    "default": dj_database_url.config(
        default=os.getenv("DATABASE_URL"), conn_max_age=600, ssl_require=True
    )
}

# REST Framework
REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.SessionAuthentication",
        "rest_framework.authentication.BasicAuthentication",
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticated",
    ],
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 10,
}

# Internationalization
LANGUAGE_CODE = "en-us"
TIME_ZONE = "UTC"
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = "static/"
STATIC_ROOT = os.path.join(BASE_DIR, "staticfiles")

# Media files
MEDIA_URL = "media/"
MEDIA_ROOT = os.path.join(BASE_DIR, "media")

# Default primary key field type
DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# CORS
CORS_ALLOWED_ORIGINS = os.getenv("CORS_ALLOWED_ORIGINS", "").split(",")
CORS_ALLOW_CREDENTIALS = True

# Celery
CELERY_BROKER_URL = os.getenv("CELERY_BROKER_URL", "redis://localhost:6379/0")
CELERY_RESULT_BACKEND = os.getenv("CELERY_RESULT_BACKEND", "redis://localhost:6379/0")
------
./src/infrastructure/django/urls.py
from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import include, path
from django.views.generic import RedirectView
from rest_framework import routers
from src.infrastructure.django.views import (
    AnalysisViewSet,
    DatasetViewSet,
    LoginView,
    ProjectViewSet,
)

# Create the router
router = routers.DefaultRouter()
router.register(r"projects", ProjectViewSet)
router.register(r"datasets", DatasetViewSet)
router.register(r"analyses", AnalysisViewSet)

urlpatterns = [
    # Redirect root URL to API
    path("", RedirectView.as_view(url="/api/", permanent=False)),
    path("admin/", admin.site.urls),
    path("api/", include(router.urls)),
    path("api/auth/login", LoginView.as_view(), name="login"),
    path("api-auth/", include("rest_framework.urls", namespace="rest_framework")),
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
------
./src/infrastructure/django/views.py
# src/infrastructure/django/views.py
import pandas as pd
from asgiref.sync import async_to_sync
from django.contrib.auth import authenticate
from rest_framework import status, viewsets
from rest_framework.authtoken.models import Token
from rest_framework.decorators import action
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.request import Request
from rest_framework.response import Response
from rest_framework.views import APIView
from src.application.use_cases.perform_mann_kendall_analysis import (
    PerformMannKendallAnalysis,
)
from src.infrastructure.django.serializers import (
    AnalysisSerializer,
    DatasetSerializer,
    ProjectSerializer,
)
from src.infrastructure.repositories.django_analysis_repository import (
    DjangoAnalysisRepository,
)

from .models import AnalysisModel, DatasetModel, ProjectModel


class ProjectViewSet(viewsets.ModelViewSet):
    queryset = ProjectModel.objects.all()
    serializer_class = ProjectSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return self.queryset.filter(owner=self.request.user)

    def perform_create(self, serializer):
        serializer.save(owner=self.request.user)


class DatasetViewSet(viewsets.ModelViewSet):
    queryset = DatasetModel.objects.all()
    serializer_class = DatasetSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return self.queryset.filter(project__owner=self.request.user)

    @action(detail=True, methods=["post"])
    def analyze(self, request: Request, pk=None) -> Response:
        """
        Perform Mann-Kendall analysis on the dataset
        """
        dataset = self.get_object()

        try:
            # Read the dataset file
            file_path = dataset.file.path
            df = pd.read_excel(file_path, header=None, index_col=0)

            # Initialize use case and repository
            repository = DjangoAnalysisRepository()
            use_case = PerformMannKendallAnalysis(repository)

            # Execute analysis using async_to_sync
            results = async_to_sync(use_case.execute)(dataset.id, df)

            # Update dataset status
            dataset.processed = True
            dataset.save()

            # Return success response
            return Response(
                {
                    "message": "Analysis completed successfully",
                    "results_count": len(results),
                },
                status=status.HTTP_200_OK,
            )

        except Exception as e:
            return Response(
                {"error": f"Analysis failed: {str(e)}"},
                status=status.HTTP_400_BAD_REQUEST,
            )


class AnalysisViewSet(viewsets.ModelViewSet):
    queryset = AnalysisModel.objects.all()
    serializer_class = AnalysisSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return self.queryset.filter(dataset__project__owner=self.request.user)

    @action(detail=False, methods=["get"])
    def dataset_results(self, request):
        """
        Get all analysis results for a specific dataset
        """
        dataset_id = request.query_params.get("dataset_id")
        if not dataset_id:
            return Response(
                {"error": "dataset_id is required"}, status=status.HTTP_400_BAD_REQUEST
            )

        repository = DjangoAnalysisRepository()
        # Convert async operation to sync
        results = async_to_sync(repository.list_by_dataset)(dataset_id)

        return Response(
            [
                {
                    "well_name": r.well_name,
                    "parameter": r.parameter,
                    "trend": r.trend,
                    "statistic": r.statistic,
                    "coefficient_variation": r.coefficient_variation,
                    "confidence_factor": r.confidence_factor,
                    "data_points": r.data_points,
                    "minimum_value": r.minimum_value,
                    "maximum_value": r.maximum_value,
                    "mean_value": r.mean_value,
                    "analysis_date": r.analysis_date,
                }
                for r in results
            ]
        )


class LoginView(APIView):
    """
    View para autenticação de usuários.
    """

    permission_classes = [AllowAny]

    def post(self, request):
        username = request.data.get("username")
        password = request.data.get("password")
        user = authenticate(username=username, password=password)

        if user is not None:
            token, _ = Token.objects.get_or_create(user=user)
            return Response({"token": token.key}, status=status.HTTP_200_OK)
        return Response(
            {"error": "Invalid credentials"}, status=status.HTTP_401_UNAUTHORIZED
        )
------
./src/infrastructure/django/wsgi.py
"""
WSGI config for project.
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "src.infrastructure.django.settings")

application = get_wsgi_application()
------
./src/infrastructure/services/__init__.py
------
./src/domain/value_objects/__init__.py
------
./src/domain/__init__.py
------
./src/domain/ports/analysis_repository.py
from abc import ABC, abstractmethod
from typing import List, Optional
from uuid import UUID

from src.domain.entities.analysis_result import AnalysisResult


class AnalysisRepository(ABC):
    """Interface for analysis results repository"""

    @abstractmethod
    async def save(self, result: AnalysisResult) -> AnalysisResult:
        """Save analysis result"""
        pass

    @abstractmethod
    async def get_by_id(self, result_id: UUID) -> Optional[AnalysisResult]:
        """Get analysis result by ID"""
        pass

    @abstractmethod
    async def list_by_dataset(self, dataset_id: UUID) -> List[AnalysisResult]:
        """List all results for a dataset"""
        pass
------
./src/domain/ports/__init__.py
------
./src/domain/ports/project_repository.py
from abc import ABC, abstractmethod
from typing import List, Optional
from uuid import UUID

from src.domain.entities.project import Project


class ProjectRepository(ABC):
    """Interface para repositório de projetos"""

    @abstractmethod
    async def save(self, project: Project) -> Project:
        """Salva um projeto no repositório"""
        pass

    @abstractmethod
    async def get_by_id(self, project_id: UUID) -> Optional[Project]:
        """Recupera um projeto pelo ID"""
        pass

    @abstractmethod
    async def list_by_owner(self, owner_id: UUID) -> List[Project]:
        """Lista todos os projetos de um proprietário"""
        pass

    @abstractmethod
    async def delete(self, project_id: UUID) -> None:
        """Remove um projeto do repositório"""
        pass

    @abstractmethod
    async def update(self, project: Project) -> Project:
        """Atualiza um projeto existente"""
        pass
------
./src/domain/entities/analysis_result.py
from dataclasses import dataclass
from datetime import datetime
from uuid import UUID


@dataclass
class AnalysisResult:
    """Entity representing the result of a Mann-Kendall analysis"""

    well_name: str
    parameter: str
    trend: str
    statistic: float
    coefficient_variation: float
    confidence_factor: float
    analysis_date: datetime
    id: UUID
    dataset_id: UUID
    data_points: int
    minimum_value: float
    maximum_value: float
    mean_value: float
------
./src/domain/entities/__init__.py
------
./src/domain/entities/project.py
from dataclasses import dataclass
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4


@dataclass
class Project:
    """Entidade Project do domínio"""

    name: str
    description: Optional[str]
    owner_id: UUID
    created_at: datetime
    updated_at: datetime
    id: UUID = uuid4()

    def update_description(self, new_description: str) -> None:
        """Atualiza a descrição do projeto"""
        self.description = new_description
        self.updated_at = datetime.utcnow()

    @classmethod
    def create(cls, name: str, description: str, owner_id: UUID) -> "Project":
        """Factory method para criar um novo projeto"""
        now = datetime.utcnow()
        return cls(
            name=name,
            description=description,
            owner_id=owner_id,
            created_at=now,
            updated_at=now,
        )
